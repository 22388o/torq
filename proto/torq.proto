syntax = "proto3";

option go_package = "github.com/lncapital/torq/torqrpc";

package torqrpc;

service torqrpc {
  rpc GetAggrigatedForwards (AggregatedForwardsRequest) returns (AggregatedForwardsResponse);
}


// ------------------------------------------------------------------
// Aggregated forwards
// ------------------------------------------------------------------
message AggregatedForwardsRequest {

  // From what date/time (unix timestamp)
  int64 from_ts = 1;

  // To what date/time (unix timestamp)
  int64 to_ts = 2;

  oneof ids {
    ChannelIDs channel_ids = 3;
    PeerIDs peer_ids = 4;
    TagIDs tag_ids = 5;
  }
}

message AggregatedForwardsResponse {

  // From what date/time (unix timestamp)
  int64 from_ts = 1;

  // To what date/time (unix timestamp)
  int64 to_ts = 2;

  // This represents the type of aggregation
  // 0 = CHANNEL, means forwards are aggregated per channel
  // 1 = PEER, means forwards are aggregated per peer (remote public key)
  // 1 = TAG, means forwards are aggregated per tag, tags are a user defined group of channels.
  GroupType group_type = 3;

  // a list of aggregated forwarding stats
  repeated AggregatedForwards aggregated_forwards = 4;
}

// AggregatedForwards represents a channels, peers or tags aggregated forwarding stats.
message AggregatedForwards {

  // A list of the channel included in the aggregated result.
  repeated ChanInfo channels = 1;

  // This represents the type of aggregation
  // 0 = CHANNEL, means forwards are aggregated per channel
  // 1 = PEER, means forwards are aggregated per peer (remote public key)
  // 1 = TAG, means forwards are aggregated per tag, tags are a user defined group of channels.
  GroupType group_type = 2;

  // The group_id depends on the granularity requested.
  //   * Channel ID for individual channels
  //   * Remote peers public key when it's grouped per peer
  //   * Tag id when it's grouped by tag.
  string group_id = 4;

  // The group_name depends on the granularity requested.
  //   * Individual channels use the format: <Alias> (<Channel ID>)
  //   * Peer grouped use the format: <Alias>
  //   * Tag groups use the format: <Tag Name>
  string group_name = 5;

  // The  utbound amount in sats (Satoshis)
  uint64 amount_out = 6;

  // The inbound amount in sats (Satoshis)
  uint64 amount_in = 7;

  // The total amount forwarded both inbound and outbound
  uint64 amount_total = 15;

  // The outbound revenue in sats. This is what the channel has directly produced.
  uint64 revenue_out = 8;

  // The inbound revenue in sats. This is what the channel has indirectly produced.
  // This revenue are not really earned by this channel/peer/group, but represents
  // the channel/peer/group contribution to revenue earned by other channels.
  uint64 revenue_in = 9;

  // Total revenue
  uint64 revenue_total = 14;

  // Number of outbound forwards.
  uint64 count_out = 10;

  // Number of inbound forwards.
  uint64 count_in = 11;

  // Number of inbound forwards.
  uint64 count_total = 12;

  // The total capacity of this channel
  uint64 capacity = 13;

  // Turnover = capacity/amount_total. It is a measure of how many times
  // the capital is used in the given time interval.
  float turnover = 16;

}

message ChannelIDs {
  // A list of channel IDs
  repeated uint64 chan_ids = 1 [jstype = JS_STRING];
}

message PeerIDs {
  // A list of public kees belonging to peers you have channels with
  repeated string pub_keys = 1;
}

message TagIDs {
  // A list of tag ids
  repeated string tag_ids = 1;
}


message ChanInfo {

  // The channel ID
  uint64 chan_id = 1;

  // Alias of remote peer
  string alias = 2;

  // The remote public key
  string pub_key = 3;

  // True if the channel is closed
  bool closed = 5;

  // A list of tags associated with this channel
  repeated string tags = 4;
}

enum GroupType {
    CHANNEL = 0;
    PEER = 1;
    TAG = 2;
}
import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState, AppThunk } from '../../store/store';
import {log} from "util";
import {addDays, format} from 'date-fns';
import {FilterInterface, FilterFunctions, applyFilters} from './filter'

export interface TableState {
  channels: [];
  filters: Array<FilterInterface>;
  status: 'idle' | 'loading' | 'failed';
}

const initialState: TableState = {
  channels: [],
  filters: [],
  status: 'idle',
};
const init: RequestInit = {
  // credentials: 'include',
  headers: {'Content-Type':'application/json'},
  mode: 'cors',
  // referrerPolicy: 'origin-when-cross-origin'
};

function fetchChannels(from: string, to: string) {
  to = format(addDays(new Date(to), 1), "yyyy-MM-dd")
  const body = fetch(`http://localhost:8080/api/channels?from=${from}&to=${to}`,init)
    .then(response => {
      return response.json()
    })
  return body
}

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const fetchChannelsAsync = createAsyncThunk(
  'table/fetchChannels',
  async (data: {from: string, to: string}) => {
    const response = await fetchChannels(data.from, data.to);
    return response
  }
);


export const tableSlice = createSlice({
  name: 'table',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    updateFilters: (state, actions) => {
      state.filters = actions.payload
      // @ts-ignore
      state.channels = applyFilters(state.filters, state.channels)
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(fetchChannelsAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchChannelsAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        state.channels = applyFilters(state.filters, action.payload);
      });
  },
});

export const { updateFilters } = tableSlice.actions;

export const selectChannels = (state: RootState) => state.table.channels;

export default tableSlice.reducer;
